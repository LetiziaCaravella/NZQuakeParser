import os
import glob
import asyncio
import nest_asyncio
import aiohttp

from functions import get_ID_for_download, parse_data, save_to_csv

# Allow nested event loops (required for Jupyter/IPython)
nest_asyncio.apply()

# -------------------------------
# Define folders
# -------------------------------
queryfolder = "./query/"
idfolder = "./IDS/"
OUTPUT_FOLDER = "./earthquake_data/"
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

# -------------------------------
# Generate ID files from GeoNet CSV catalogues
# -------------------------------
catalogue = get_ID_for_download(queryfolder, idfolder)
print(f"✅ Catalogue prepared with {len(catalogue)} earthquake entries.")


# -------------------------------
# Error tracking setup
# -------------------------------
error_count = 0
error_list = []


# -------------------------------
# Async function to fetch one event
# -------------------------------
async def fetch_data(session, public_id):
    """
    Fetch and parse one earthquake event from GeoNet.

    Input:
    session : aiohttp.ClientSession
        The active HTTP session used for making asynchronous requests.
    public_id : str
        The unique GeoNet event ID to be fetched.

    Output:
    dict or None
        Parsed data dictionary for one earthquake event (from `parse_data()`),
        or None if the request fails or parsing encounters an error.
    """
    
    global error_count

    url = f"https://www.geonet.org.nz/earthquake/technical/{public_id}"

    try:
        # Send an asynchronous HTTP GET request
        async with session.get(url) as response:
            if response.status != 200:
                # Log failed requests
                error_count += 1
                error_list.append(f"{error_count}. Error fetching {public_id}: HTTP {response.status}")
                return None

            # Read HTML and parse event details
            html = await response.text()
            return parse_data(html, public_id)

    except Exception as e:
        # Handle connection timeouts, etc.
        error_count += 1
        error_list.append(f"{error_count}. Error fetching {public_id}: {e}")
        return None


# -------------------------------
# Gather multiple events concurrently
# -------------------------------
async def gather_data(public_ids):
    """
    Fetch and parse multiple GeoNet events concurrently.

    Input:
    public_ids : list of str
        List of GeoNet public event IDs to fetch.

    Output:
    list of dict
        A list of parsed event dictionaries (from `fetch_data()`),
        with None for events that failed to fetch or parse.
    """
    
    async with aiohttp.ClientSession() as session:
        # Create async tasks for all event IDs
        tasks = [fetch_data(session, pub_id) for pub_id in public_ids]
        return await asyncio.gather(*tasks)


# -------------------------------
# Main driver function
# -------------------------------
async def main():
    """
    Main asynchronous driver.
    Loops through all `.dat` ID files generated by `get_ID_for_download()`,
    reads each file's event IDs, fetches corresponding GeoNet pages,
    parses data, and saves results into `.csv` files.
    """
    
    id_files = glob.glob(os.path.join(idfolder, "*.dat"))
    print(f"Found {len(id_files)} ID files to process.")

    for id_file in id_files:
        basename = os.path.basename(id_file).replace("_ID.dat", "")
        output_file = f"{basename}_earthquake_data.csv"

        # Read event IDs
        with open(id_file, "r") as f:
            public_ids = [line.strip() for line in f.readlines() if line.strip()]

        print(f"\nFetching {len(public_ids)} events for {basename}...")

        # Fetch all data concurrently
        data_list = await gather_data(public_ids)

        # Save to CSV
        save_to_csv(data_list, filename=output_file, output_folder=OUTPUT_FOLDER)

        print(f"Finished {basename}, saved {len([d for d in data_list if d])} entries.")

    # Print summary of any errors
    if error_list:
        print("\n⚠️ Some errors occurred:")
        for err in error_list:
            print(err)
    else:
        print("\nAll done with no errors!")


if __name__ == "__main__":
    print("Detected script — using 'asyncio.run(main())'")
    asyncio.run(main())
